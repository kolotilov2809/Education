'use strict';

//классы - это красивая обертка функции конструктора (синтаксический сахар)
//классы внутри это теже функции

//создание класса начинается с ключевого слова class, далее задаем название класса Rectangle, который ОБЯЗАТЕЛЬНО должен начинатсья с большой буквы. Далее раскрываем фигурные скобки
class Rectangle {
    //далее надо класс сконструировать: то есть какие вещи будут включены в этот шаблон, что будет уметь этот класс, какие св-ва в нем будут заданы изначально. Самое главное это те параметры, которые будут передаваться из вне.
    constructor(height, width) {//конструирование начинается со св-ва constructor. его раскрываем через круглые скобки, потом через фигурные. В круглых мы как обычную функцию записываем аргументы, которые будут приходить. В данном примере у прямоугольника это высота и ширина. Два этих параметра будут приходить из вне при создании экземпляра класса
        
        //После передачи этих параметров, мы должны записать их в св-ва этого нового объекта. Классы , как и функции конструктора служат нам для создания нового объектов
        this.height = height;//здесь мы обращаемся к this, то есть обращаемся к экземпляру нового созданного объекта. Записываем в каждый новый объект какое то св-во height и берем его из аргументов
        this.width = width;//тоже самое и с width
        //теперь у нас есть 2 базовых св-ва, которые будут записываться во время того, когда мы будем создавать наш класс
    }
    //теперь создадим метод. Во первых не надо ставить ';' и между методами их тоже ставить не надо.
    calcArea() {
        return this.height * this.width;//наш метод должен возвращать площадь прямоугольника. Прописыаем return, потому что мы хотим вернуть площадь, далее обращаемся к this, который обращается на новый объект который будет создан и берем из него св-во height, потом умножаем на this.width
    }
}

//для проверки создадим переменную square и в нее помещаем новый объект, который создается при помощи класса и во внутрь помещаем два аргумента new Rectangle(10,10).
//теперь в переменной square лежит объект у которого есть два св-ва height и  width и есть один метод calcArea
const square = new Rectangle(10,10);
const long = new Rectangle(6,8);

//обратимся к объекту square и используем метод calcArea. Так как это метод, обязательно ставим круглые скобки, чтобы он вызвался
console.log(square.calcArea());
console.log(long.calcArea());


//Принципы ООП
//1) Абстракция - когда отделяем концепцию от ее экземпляра

//Концепция. Какой то небольшой шаблон, по которому мы создаем 
/* class Rectangle {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
    calcArea() {
        return this.height * this.width;
    }
} */

//Экземпляры, которые были созданы на основе нашей концепции
/* const square = new Rectangle(10,10);
const long = new Rectangle(6,8); */

//2) Наследование - способность нашего объекта или класса базироваться на другом объекте или классе. Главный механизм для использования повторного кода. Наследственное отношение классов четко будет определять их иерархию

//создадим класс у которого будут прямоугольники еще с текстом и цветом
//Дублировать код ни к чему. Мы можем сделать наследуемость
//класс ColoredRectangleWithText будет наследоваться от класса Rectangle.Будет брать  у него те св-ва, которые  у него записаны и те методы, которые там существуют. Для этого используют ключевое слово extends. класс ColoredRectangleWithText наследуется от extends класса Rectangle
class ColoredRectangleWithText extends Rectangle {
    constructor(height, width, text, bgColor) {//далее точно так же вызываем constructor. Мы знаем что для этого класса понадобится аргументы, которые мы бкдем так же передавать. Это  height, width, text, bgColor
        super(height,width);//Далее мы так же понимаем что нам придется прописывать this.height = height; this.width = width;. И чтобы нам не заниматься копированием, мы воспользуемся методом super(). Это универпсальная вещь, которая вызывает супер конструктор родителя. Она вызывает тоже самое, что было у родителя. Соответственно повторять строки this.height = height; this.width = width; нам уже не нужно. Они автоматически перейдут за счет наследования.
        //Главное правило: super() всегда должна быть на первом месте в конструкторе. Далее туда можем указать те св-ва, которые хотим использовать. В данном случае  это height,width. Св-ва которые нам не нужны, их можно не указывать
        this.text = text;//Далее повторяем действия уже знакомые нам
        this.bgColor = bgColor;
    }

    //так же в этом классе будет использоваться и метод calcArea(), который тоже можно будет применять

    //Проверим, что св-ва text и bgColor тоже работают.
    //Создадим метод showMyProps()
    showMyProps() {
        console.log(`Текст: ${this.text}, цвет: ${this.bgColor}`);
    }
}

//Создадим переменную div, куда поместим конструктор  ColoredRectangleWithText
const div = new ColoredRectangleWithText(25,10, 'Hello World', 'red');

div.showMyProps();//проверим как работает метод для проверки text и bgColor
console.log(div.calcArea());//Здесь проверим, как работает унаследованный метод calcArea