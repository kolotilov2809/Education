//синтаксис setTimeout
//Зачем задавать переменную setTimeout. Это делается для определения четкого setTimeout. На странице может быть очень много таких асинхронных функций. А определять их нам надо, чтобы в будущем их как то останавливать
const timeId = setTimeout(function() {//сначала принимают ту функцию, которая должна запуститься через определенное время
    console.log('Hello');
}, 2000);//вторым аргументом время, через которое она должна запуститься в миллисекундах

//так же можно передать аргументы, которые будут аргументами для функции внутри
const timeId = setTimeout(function(text) {
    console.log(text);
}, 2000, 'world');//в консоль передастся world 

//так же можно передавать готовую функцию
const timeId = setTimeout(logger, 5000);
function logger() {
    console.log('text');
}

//Бывает когда заходишь на сайт то например должно появиться какое то модальное окно через 30 секунд. Но если Вы нажали уже на какую то кнопку, то это окно появиться не должно(setTimeout должен сброситься)
const timeId = setTimeout(logger, 5000);

clearInterval(timeId);//для остановки setTimeout

function logger() {
    console.log('text');
}

//Примеры
let timeId,
    i = 0;
const btn = document.querySelector('.btn');//получаем кнопку по классу
btn.addEventListener('click', () => {
    // const timeId = setTimeout(logger, 5000);
    timeId = setInterval(logger, 500);//setInterval - для того чтобы скрипт повторялся через определенное промежуток времени. Для того чтобы остановить setInterval, надо использовать clearInterval()
});

function logger() {
    if (i===3) {
        clearInterval(timeId);
    }
    console.log('text');
    i++;
}

//Чем рекурсивный setTimeout лучше setInterval.
//Рекурсия - по факту это когда функция сама себя внутри вызывает
//И получается что setTimeout может вызвать внутри себя еще один setTimeout. И проблема здесь вот: когда таймер с интервалом работает он не учитывает как долго будет работать функция внутри него (это про setInterval). То есть сначала выполняется функция logger, потом задержка , потом снова функция и тд. Если функция тяжелая , то она будет не успевать выполняться, а задержка уже пройдет.
//Для решения такой проблемы используют рекурсивный setTimeout
// код будет ждать строго отведенное ему время
//запускаем setTimeout, далее ждет 800 и потом запускаем всю функцию log. в console.log('Hello') выполняются определенные действия (не важно сколько по времени). наш следующий setTimeout будет ждать. Далее оно сделает паузу на 500 и снова запустит log
let id = setTimeout(function log() {
    console.log('Hello');
    id = setTimeout(log, 500); 
}, 800);

//реализация самой простой анимации, кк делаллось раньше
function myAnimation() {
    const elem = document.querySelector('.box');//получаем квадрат со страницы с классом box
    let pos = 0;//переменная позиции с которой будет стартовать квадрат

    const id = setInterval(frame, 10);//запускаем интервал. 
    function frame() {//функция кадр для определения, что анимация закончилась. Мы это будем делать по переменной pos
        if (pos == 300) {//сравниваем pos с конечной позицией
            clearInterval(id);//для остановки анимации при достижении 300
        } else {//если анимация продолжается, то выполняем следующие действия
            pos++;//увеличиваем начальную позицию на 1
            elem.style.top = pos + 'px';//смещение по top =  наша pos + пиксель(для правильного отображения)
            elem.style.left = pos + 'px';//смещение по left =  наша pos + пиксель(для правильного отображения)
        }
    }
}

btn.addEventListener('click', myAnimation);