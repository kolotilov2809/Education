'use strict';
//функция по своей сути является объектом и по идее в нее можно записать методы и сво-ва.
//существует длинный синтаксис для создания типов данных, которые начинаются с ключевого слова new
//Конструкторы нужны для создания новых однотипных объектов(в практике это могут быть новые польз-ли на сайте, товары в магазинах, ролики на ютубе), везде где есть шаблонизация.

const num = new Number(3);//создадим переменную num  и во внутрь как бы создание нового числа
console.log(num);

//создание функции. Вот если такая функция будет содержать методы и св-ва, то она в итоге создаст нам новый объект. То есть созданием новой функции мы создаем новый объект, св-ва которого уже описаны в этой функции
const num = new Function(3);
console.log(num);


//реальный пример
//создадим новую функцию User, которая принимает в себе 2 аргумента name, id
//вот такие функции предназначены для конструирования объектов и создания множества подобных копий
function User(name, id) {
    //запишем сво-ва, которые хотим что бы отображались как в объекте
    //обращаемся через ключевое слово this. для каждого отдельного пользователя будем указывать имя и идентиф номер
    this.name = name;//второй name берем из наших аргументов
    this.id = id;//тоже самое и с id
    this.human = true;//запишем еще одно св-во. которе будет общим для всех

    //вот теперь, когда использован такой синтаксис наша функция стала конструктором. С ее помощью мы можем создавать новых пользователей

    //так же можно использовать различные методы. Если создать метод один раз в нашем прототипе, он будет у каждого из наших потомков
    this.hello = function() {//это метод, поэтому кладем сюда функцию
        console.log(`Hello ${this.name}`);//можем использовать какие то св-ва, которые у нас уже есть, например name
    };
}

//по стандарту ES6 это реализуется через класы
class User {
    constructor(name, id) {
        this.name = name;
        this.id = id;
        this.human = true;
    }
    hello() {
        console.log(`Hello ${this.name}`)
    }
    exit() {
        console.log(`Пользователь ${this.name} ушел`)
    }
}

//при помощи св-ва prototype можно добавлять новые методы или св-ва в наш конструктор и они будут прототипно наследоваться у потомков.этот прием используется когда нет доступа к нашему прототипу или мы не можем его менять по каким то причинам, но при этом его нужно немного модифицировать 
User.prototype.exit = function() {//обращаемся к User, обращаемся к его prototype и сделаем метод exit.
    console.log(`Пользователь ${this.name} ушел`);
    //теперь у нас прототипно будет наследоваться и этот метод и он появится у всех потомков , которые написаны после него, которые были созданы после объявления этого метода
};

// создадим новые переменные и во внутрь помещаем следующую конструкцию new User и задаем 2 аргумента, которые будут характеризовать этого пользователя
const ivan = new User('Ivan', 28);
const alex = new User('Alex', 20);

ivan.exit();

//у нас получились объекты. В фигурных скобках объект содержит св-во name со значениями Ivan и Alex, св-во id 28 и 20, и так же св-во human одинаковое для всех
console.log(ivan);
console.log(alex);

ivan.hello();
alex.hello();