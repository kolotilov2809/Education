// 'use strict';

const persone = {
    name: 'Alex',
    age: 25,

    get userAge() {
        return this.age;
    },

    set userAge(num) {
        this.age = num;
    }
};

console.log(persone.userAge = 30);
console.log(persone.userAge);

//Инкапсуляция

/* Инкапсуляция (encapsulation) - это механизм, который объединяет данные и код, манипулирующий зтими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. В объектно-ориентированном программировании код и данные могут быть объединены вместе; в этом случае говорят, что создаётся так называемый "чёрный ящик". Когда коды и данные объединяются таким способом, создаётся объект (object). Другими словами, объект - это то, что поддерживает инкапсуляцию.

Внутри объекта коды и данные могут быть закрытыми (private). Закрытые коды или данные доступны только для других частей этого объекта. Таким образом, закрытые коды и данные недоступны для тех частей программы, которые существуют вне объекта. Если коды и данные являются открытыми, то, несмотря на то, что они заданы внутри объекта, они доступны и для других частей программы. Характерной является ситуация, когда открытая часть объекта используется для того, чтобы обеспечить контролируемый интерфейс закрытых элементов объекта.

На самом деле объект является переменной определённого пользователем типа. Может показаться странным, что объект, который объединяет коды и данные, можно рассматривать как переменную. Однако применительно к объектно-ориентированному программированию это именно так. Каждый элемент данных такого типа является составной переменной. */

function User(name, age) {//функция конструктор, принимает 2 аргумента. Конструируем новый объект
    this.name = name;//со св-вом name
    //this.age = age//со св-вом age
    let userAge = age;//без set и get , выводиться будет undefined, так как св-во userAge сохранили внутри объекта и снаружи нет доступа

    this.say = function() {//метод say - это функция
        console.log(`Имя пользователя: ${this.name}, возраст ${userAge}`);
    };

    //методы getAge - позволяют отдавать значение наружу и setAge - позволяет изменять
    this.getAge = function() {
        return userAge;
    };

    this.setAge = function(age) {
        if (typeof age === 'number' && age > 0 && age < 110) {
            userAge = age;
        } else {
            console.log('Недопустимое значение');
        }
    };
}

const ivan = new User('Ivan', 27);//создаем объект ivan
console.log(ivan.name);//вывод Ivan
console.log(ivan.getAge());//вывод 27

ivan.setAge(30);//setAge устанавливает значение 30 в userAge
ivan.setAge(300);//Недопустимое значение
console.log(ivan.getAge());//вывод 30
// ivan.name = 'Alex';

//метод скажет какие значения у нас есть в объекте
ivan.say();//Имя пользователя: Ivan, возраст 30

class User {
    constructor(name, age) {     
        this.name = name;
        this._age = age;//чтобы скрыть св-во от изменений, имя св-ва начинается с '_'. Договоренность между разработчиками
    }

    #surname = 'Kolo';

   say = () => {
        console.log(`Имя пользователя: ${this.name}${this.#surname}, возраст ${this._age}`);
    }

   get age() {
        return this._age;
    }

    set age(age) {
        if (typeof age === 'number' && age > 0 && age < 110) {
            this._age = age;
        } else {
            console.log('Недопустимое значение');
        }
    }
}

const ivan = new User('Ivan', 27);
console.log(ivan.age);
ivan.age = 99;
console.log(ivan.age);
ivan.name = 'Alex';
console.log(ivan.surname);
ivan.say();